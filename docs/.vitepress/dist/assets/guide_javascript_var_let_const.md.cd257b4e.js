import{o as n,c as a,a as s}from"./app.78bcef79.js";const t='{"title":"var、let和const区别的实现原理是?","description":"","frontmatter":{"title":"var、let和const区别的实现原理是?"},"headers":[{"level":2,"title":"var 操作符（关键字）","slug":"var-操作符（关键字）"},{"level":2,"title":"使用let的块级作用域声明","slug":"使用let的块级作用域声明"},{"level":2,"title":"使用const的常量声明","slug":"使用const的常量声明"},{"level":3,"title":"Object.freeze()","slug":"object-freeze"}],"relativePath":"guide/javascript/var_let_const.md","lastUpdated":1625578115392}',e={},o=s('<h1 id="var、let-和-const-区别的实现原理是什么"><a class="header-anchor" href="#var、let-和-const-区别的实现原理是什么" aria-hidden="true">#</a> var、let 和 const 区别的实现原理是什么</h1><h2 id="var-操作符（关键字）"><a class="header-anchor" href="#var-操作符（关键字）" aria-hidden="true">#</a> var 操作符（关键字）</h2><p>在使用var声明变量时，变量会被自动添加到最接近的上下文。在函数中，最接近的上下文就是函数的局部上下文。在with语句中，最接近的上下文也是函数上下文。如果变量未经声明就被初始化了，那么它就会自动被添加到全局上下文</p><h2 id="使用let的块级作用域声明"><a class="header-anchor" href="#使用let的块级作用域声明" aria-hidden="true">#</a> 使用let的块级作用域声明</h2><p>但它的作用域是块级的，这也是JavaScript中的新概念。块级作用域由最近的一对包含花括号{}界定。换句话说，if块、while块、function块，甚至连单独的块也是let声明变量的作用域。let与var的另一个不同之处是在同一作用域内不能声明两次。重复的var声明会被忽略，而重复的let声明会抛出SyntaxError。 当<code>let</code>的值修改之后，之前的值就删除了</p><h2 id="使用const的常量声明"><a class="header-anchor" href="#使用const的常量声明" aria-hidden="true">#</a> 使用const的常量声明</h2><p>除了let，ES6同时还增加了const关键字。使用const声明的变量必须同时初始化为某个值。一经声明，在其生命周期的任何时候都不能再重新赋予新值。 <strong>const声明只应用到顶级原语或者对象。换句话说，赋值为对象的const变量不能再被重新赋值为其他引用值，但对象的键则不受限制。</strong> 其本质是：并不是变量的值不得改动，而是变量指向的那个内存地址所保存的数据不得改动。变量指向的内存地址，保存的只是一个指向实际数据的指针，const只能保证这个指针是固定的（即总是指向另一个固定的地址），至于它指向的数据结构是不是可变的，就完全不能控制了。因此，将一个对象声明为常量必须非常小心</p><div class="language-js"><pre><code> <span class="token keyword">const</span> o <span class="token operator">=</span> <span class="token punctuation">{</span>\n      name<span class="token operator">:</span><span class="token string">&#39;yayxs&#39;</span><span class="token punctuation">,</span>\n      age<span class="token operator">:</span><span class="token number">18</span>\n    <span class="token punctuation">}</span>\n    Object<span class="token punctuation">.</span><span class="token function">freeze</span><span class="token punctuation">(</span>o<span class="token punctuation">)</span>\n    o<span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">&#39;subs&#39;</span>\n    <span class="token keyword">const</span> o3 <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">freeze</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n    o3<span class="token punctuation">.</span>name<span class="token operator">=</span> <span class="token string">&#39;yyx&#39;</span>\n    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>o3<span class="token punctuation">.</span>name<span class="token punctuation">)</span> <span class="token comment">// undefined</span>\n    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>o<span class="token punctuation">.</span>name<span class="token punctuation">)</span> <span class="token comment">// yayxs</span>\n</code></pre></div><p>该尽可能地多使用const声明，除非确实需要一个将来会重新赋值的变量。这样可以从根本上保证提前发现重新赋值导致的bug。</p><h3 id="object-freeze"><a class="header-anchor" href="#object-freeze" aria-hidden="true">#</a> Object.freeze()</h3><p>如果想让整个对象都不能修改，可以使用Object.freeze()</p>',11);e.render=function(s,t,e,p,c,l){return n(),a("div",null,[o])};export default e;export{t as __pageData};
