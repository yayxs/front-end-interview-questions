import{o as n,c as s,a}from"./app.0c83b2b0.js";const p='{"title":"JS中的变量声明提升","description":"","frontmatter":{"title":"JS中的变量声明提升"},"headers":[{"level":2,"title":"带来的问题","slug":"带来的问题"}],"relativePath":"guide/javascript/hoisting.md","lastUpdated":1618228126099}',t={},o=a('<p><strong>var 声明会被拿到函数或全局作用域的顶部，位于作用域中所有代码之前。这个现象叫作“提升”</strong></p><p>提升让同一作用域中的代码不必考虑变量是否已经声明就可以直接使用。可是在实践中，提升也会导致合法却奇怪的现象，即在变量声明之前使用变量。</p><blockquote><p>打个比方，这个过程就好像变量和函数声明从它们在代码中出现的位置被“移动” 到了最上面。这个过程就叫作提升。</p></blockquote><div class="language-js"><pre><code><span class="token keyword">function</span> <span class="token function">fn1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">var</span> name <span class="token operator">=</span> <span class="token string">&#39;Jake&#39;</span>\n<span class="token punctuation">}</span>\n\n<span class="token comment">// 等价于：</span>\n<span class="token keyword">function</span> <span class="token function">fn2</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">var</span> name\n  name <span class="token operator">=</span> <span class="token string">&#39;Jake&#39;</span>\n<span class="token punctuation">}</span>\n</code></pre></div><div class="language-js"><pre><code><span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// 1</span>\n<span class="token keyword">var</span> foo\n<span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>\n<span class="token punctuation">}</span>\n<span class="token function-variable function">foo</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span>\n<span class="token punctuation">}</span>\n</code></pre></div><div class="language-js"><pre><code><span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>\n<span class="token punctuation">}</span>\n\n<span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span>\n</code></pre></div><p>正是由于 JavaScript 存在变量提升这种特性，从而导致了很多与直觉不符的代码，这也是 JavaScript 的一个重要设计缺陷。</p><h2 id="带来的问题"><a class="header-anchor" href="#带来的问题" aria-hidden="true">#</a> 带来的问题</h2><ol><li><p>在不被察觉的情况下 被覆盖掉</p></li><li><p>本应销毁的变量没有被销毁</p></li></ol>',9);t.render=function(a,p,t,c,e,u){return n(),s("div",null,[o])};export default t;export{p as __pageData};
