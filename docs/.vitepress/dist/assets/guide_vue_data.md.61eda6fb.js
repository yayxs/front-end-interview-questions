import{o as n,c as a,a as s}from"./app.78bcef79.js";const t='{"title":"请你谈谈 Vue 组件中的 Data","description":"","frontmatter":{},"headers":[{"level":3,"title":"请你谈谈 Vue 组件中的 Data","slug":"请你谈谈-vue-组件中的-data"},{"level":2,"title":"关于Data","slug":"关于data"},{"level":3,"title":"为什么可以通过this 直接访问 data 中的属性","slug":"为什么可以通过this-直接访问-data-中的属性"},{"level":2,"title":"关于挂载","slug":"关于挂载"},{"level":3,"title":"为什么我们开发习惯用一个 ID app的 div 做外层元素","slug":"为什么我们开发习惯用一个-id-app的-div-做外层元素"},{"level":3,"title":"为什么写 template 只能是一个根节点","slug":"为什么写-template-只能是一个根节点"},{"level":2,"title":"关于 VDOM","slug":"关于-vdom"}],"relativePath":"guide/vue/data.md","lastUpdated":1625578115400}',p={},e=s('<h3 id="请你谈谈-vue-组件中的-data"><a class="header-anchor" href="#请你谈谈-vue-组件中的-data" aria-hidden="true">#</a> 请你谈谈 Vue 组件中的 Data</h3><h4 id="data-为什么是一个函数"><a class="header-anchor" href="#data-为什么是一个函数" aria-hidden="true">#</a> Data 为什么是一个函数</h4><p>在 Vue 底层最终被处理为一个函数，这些函数的执行结果就是最终的数据，请问为什么 strats.data 会被处理为一个函数，通过函数返回的数据对象，保证每一个组件的实例都有唯一的数据副本，作用是为了避免组件之间互相影响,在初始化数据状态的时候就是通过如下的方法进行获取数据然后处理</p><div class="language-js"><pre><code><span class="token comment">// 策略函数 要求data是一个函数 否则会给出一个警告</span>\nstrats<span class="token punctuation">.</span><span class="token function-variable function">data</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span>\n  <span class="token parameter">parentVal<span class="token operator">:</span> any<span class="token punctuation">,</span>\n  childVal<span class="token operator">:</span> any<span class="token punctuation">,</span>\n  vm<span class="token operator">?</span><span class="token operator">:</span> Component</span>\n<span class="token punctuation">)</span><span class="token operator">:</span> <span class="token operator">?</span>Function <span class="token punctuation">{</span>\n  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>vm<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token comment">// 传递 vm 参数 必须要求是一个函数</span>\n    <span class="token keyword">if</span> <span class="token punctuation">(</span>childVal <span class="token operator">&amp;&amp;</span> <span class="token keyword">typeof</span> childVal <span class="token operator">!==</span> <span class="token string">&#39;function&#39;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n      process<span class="token punctuation">.</span>env<span class="token punctuation">.</span><span class="token constant">NODE_ENV</span> <span class="token operator">!==</span> <span class="token string">&#39;production&#39;</span> <span class="token operator">&amp;&amp;</span>\n        <span class="token function">warn</span><span class="token punctuation">(</span>\n          <span class="token string">&#39;The &quot;data&quot; option should be a function &#39;</span> <span class="token operator">+</span>\n            <span class="token string">&#39;that returns a per-instance value in component &#39;</span> <span class="token operator">+</span>\n            <span class="token string">&#39;definitions.&#39;</span><span class="token punctuation">,</span>\n          vm\n        <span class="token punctuation">)</span>\n\n      <span class="token keyword">return</span> parentVal\n    <span class="token punctuation">}</span>\n    <span class="token keyword">return</span> <span class="token function">mergeDataOrFn</span><span class="token punctuation">(</span>parentVal<span class="token punctuation">,</span> childVal<span class="token punctuation">)</span>\n  <span class="token punctuation">}</span>\n\n  <span class="token keyword">return</span> <span class="token function">mergeDataOrFn</span><span class="token punctuation">(</span>parentVal<span class="token punctuation">,</span> childVal<span class="token punctuation">,</span> vm<span class="token punctuation">)</span>\n<span class="token punctuation">}</span>\n</code></pre></div><h4 id="返回的不是纯对象-vue-是怎么做的"><a class="header-anchor" href="#返回的不是纯对象-vue-是怎么做的" aria-hidden="true">#</a> 返回的不是纯对象 Vue 是怎么做的</h4><div class="language-js"><pre><code><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">isPlainObject</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  data <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>\n  process<span class="token punctuation">.</span>env<span class="token punctuation">.</span><span class="token constant">NODE_ENV</span> <span class="token operator">!==</span> <span class="token string">&#39;production&#39;</span> <span class="token operator">&amp;&amp;</span>\n    <span class="token function">warn</span><span class="token punctuation">(</span>\n      <span class="token string">&#39;data functions should return an object:\\n&#39;</span> <span class="token operator">+</span>\n        <span class="token string">&#39;https://vuejs.org/v2/guide/components.html#data-Must-Be-a-Function&#39;</span><span class="token punctuation">,</span>\n      vm\n    <span class="token punctuation">)</span>\n<span class="token punctuation">}</span>\n</code></pre></div><h4 id="data-数据对象中的-key-与-methods-对象中的-key-冲突时-vue-是怎么做的"><a class="header-anchor" href="#data-数据对象中的-key-与-methods-对象中的-key-冲突时-vue-是怎么做的" aria-hidden="true">#</a> data 数据对象中的 key 与 methods 对象中的 key 冲突时 Vue 是怎么做的</h4><div class="language-js"><pre><code><span class="token keyword">if</span> <span class="token punctuation">(</span>props <span class="token operator">&amp;&amp;</span> <span class="token function">hasOwn</span><span class="token punctuation">(</span>props<span class="token punctuation">,</span> key<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  process<span class="token punctuation">.</span>env<span class="token punctuation">.</span><span class="token constant">NODE_ENV</span> <span class="token operator">!==</span> <span class="token string">&#39;production&#39;</span> <span class="token operator">&amp;&amp;</span>\n    <span class="token function">warn</span><span class="token punctuation">(</span>\n      <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">The data property &quot;</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>key<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">&quot; is already declared as a prop. </span><span class="token template-punctuation string">`</span></span> <span class="token operator">+</span>\n        <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">Use prop default value instead.</span><span class="token template-punctuation string">`</span></span><span class="token punctuation">,</span>\n      vm\n    <span class="token punctuation">)</span>\n<span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">isReserved</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token function">proxy</span><span class="token punctuation">(</span>vm<span class="token punctuation">,</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">_data</span><span class="token template-punctuation string">`</span></span><span class="token punctuation">,</span> key<span class="token punctuation">)</span>\n<span class="token punctuation">}</span>\n</code></pre></div><h4 id="为什么可以直接通过-this-xxx-访问data-里的值"><a class="header-anchor" href="#为什么可以直接通过-this-xxx-访问data-里的值" aria-hidden="true">#</a> 为什么可以直接通过 <code>this.xxx</code> 访问<code>data</code> 里的值</h4><p>proxy 函数的原理是通过 Object.defineProperty 函数在实例对象 vm 上定义与 data 数据字段同名的访问器属性，并且这些属性代理的值是 vm._data 上对应属性的值。</p><div class="language-js"><pre><code><span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">proxy</span><span class="token punctuation">(</span><span class="token parameter">target<span class="token operator">:</span> Object<span class="token punctuation">,</span> sourceKey<span class="token operator">:</span> string<span class="token punctuation">,</span> key<span class="token operator">:</span> string</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  sharedPropertyDefinition<span class="token punctuation">.</span><span class="token function-variable function">get</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token function">proxyGetter</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">[</span>sourceKey<span class="token punctuation">]</span><span class="token punctuation">[</span>key<span class="token punctuation">]</span>\n  <span class="token punctuation">}</span>\n  sharedPropertyDefinition<span class="token punctuation">.</span><span class="token function-variable function">set</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token function">proxySetter</span><span class="token punctuation">(</span><span class="token parameter">val</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">this</span><span class="token punctuation">[</span>sourceKey<span class="token punctuation">]</span><span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">=</span> val\n  <span class="token punctuation">}</span>\n  Object<span class="token punctuation">.</span><span class="token function">defineProperty</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> key<span class="token punctuation">,</span> sharedPropertyDefinition<span class="token punctuation">)</span>\n<span class="token punctuation">}</span>\n</code></pre></div><h4 id="为什么不在合并阶段就把数据合并好，而是要等到初始化的时候再合并数据？"><a class="header-anchor" href="#为什么不在合并阶段就把数据合并好，而是要等到初始化的时候再合并数据？" aria-hidden="true">#</a> 为什么不在合并阶段就把数据合并好，而是要等到初始化的时候再合并数据？</h4><p>因为 inject 和 props 这两个选项的初始化是先于 data 选项的，这就保证了我们能够使用 props 初始化 data 中的数据</p><p>这样就保证了我们在 data 中使用<code>props</code> 中的值</p><h2 id="关于data"><a class="header-anchor" href="#关于data" aria-hidden="true">#</a> 关于<code>Data</code></h2><h3 id="为什么可以通过this-直接访问-data-中的属性"><a class="header-anchor" href="#为什么可以通过this-直接访问-data-中的属性" aria-hidden="true">#</a> 为什么可以通过<code>this</code> 直接访问 data 中的属性</h3><h4 id="示例"><a class="header-anchor" href="#示例" aria-hidden="true">#</a> 示例</h4><div class="language-js"><pre><code> <span class="token function">mounted</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>msg<span class="token punctuation">)</span><span class="token punctuation">;</span>\n\tconsole<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>_data<span class="token punctuation">.</span>msg<span class="token punctuation">)</span> <span class="token comment">//</span>\n  <span class="token punctuation">}</span><span class="token punctuation">,</span>\n  <span class="token function">data</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">return</span> <span class="token punctuation">{</span>\n      msg<span class="token operator">:</span> <span class="token string">&#39;&#39;</span><span class="token punctuation">,</span>\n    <span class="token punctuation">}</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span><span class="token punctuation">,</span>\n</code></pre></div><h4 id="源码实现"><a class="header-anchor" href="#源码实现" aria-hidden="true">#</a> 源码实现</h4><div class="language-javascript"><pre><code><span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">proxy</span><span class="token punctuation">(</span><span class="token parameter">target<span class="token operator">:</span> Object<span class="token punctuation">,</span> sourceKey<span class="token operator">:</span> string<span class="token punctuation">,</span> key<span class="token operator">:</span> string</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  sharedPropertyDefinition<span class="token punctuation">.</span><span class="token function-variable function">get</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token function">proxyGetter</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">[</span>sourceKey<span class="token punctuation">]</span><span class="token punctuation">[</span>key<span class="token punctuation">]</span>\n  <span class="token punctuation">}</span>\n  sharedPropertyDefinition<span class="token punctuation">.</span><span class="token function-variable function">set</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token function">proxySetter</span><span class="token punctuation">(</span><span class="token parameter">val</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">this</span><span class="token punctuation">[</span>sourceKey<span class="token punctuation">]</span><span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">=</span> val\n  <span class="token punctuation">}</span>\n  <span class="token comment">// 当访问的时候Vue 代理了一层</span>\n  Object<span class="token punctuation">.</span><span class="token function">defineProperty</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> key<span class="token punctuation">,</span> sharedPropertyDefinition<span class="token punctuation">)</span>\n<span class="token punctuation">}</span>\n</code></pre></div><h2 id="关于挂载"><a class="header-anchor" href="#关于挂载" aria-hidden="true">#</a> 关于挂载</h2><h3 id="为什么我们开发习惯用一个-id-app的-div-做外层元素"><a class="header-anchor" href="#为什么我们开发习惯用一个-id-app的-div-做外层元素" aria-hidden="true">#</a> 为什么我们开发习惯用一个 ID <code>app</code>的 div 做外层元素</h3><h4 id="示例-1"><a class="header-anchor" href="#示例-1" aria-hidden="true">#</a> 示例</h4><div class="language-"><pre><code>&lt;body&gt;\n    &lt;div id=&quot;app&quot;&gt;&lt;/div&gt;\n    &lt;!-- built files will be auto injected --&gt;\n  &lt;/body&gt;\n</code></pre></div><h4 id="源码"><a class="header-anchor" href="#源码" aria-hidden="true">#</a> 源码</h4><div class="language-"><pre><code>/* istanbul ignore if */\n  if (el === document.body || el === document.documentElement) {\n    process.<wbr>env.NODE_ENV !== &#39;production&#39; &amp;&amp; warn(\n      `Do not mount Vue to &lt;html&gt; or &lt;body&gt; - mount to normal elements instead.`\n    )\n    return this\n  }\n</code></pre></div><h3 id="为什么写-template-只能是一个根节点"><a class="header-anchor" href="#为什么写-template-只能是一个根节点" aria-hidden="true">#</a> 为什么写 template 只能是一个根节点</h3><h4 id="示例-2"><a class="header-anchor" href="#示例-2" aria-hidden="true">#</a> 示例</h4><div class="language-"><pre><code>&lt;template&gt;\n  &lt;div id=&quot;app&quot;&gt;\n    &lt;img src=&quot;./assets/logo.png&quot;&gt;\n    &lt;router-view/&gt;\n  &lt;/div&gt;\n&lt;/template&gt;\n</code></pre></div><h2 id="关于-vdom"><a class="header-anchor" href="#关于-vdom" aria-hidden="true">#</a> 关于 VDOM</h2><p>(2)函数为什么返回一个对象，如果返回的不是个纯对象 Vue 是怎么做的？你有没有试过直接返回一个字符串或者其他类型 (3)data 中的 key 与 props 或者 methods 中冲突 vue 是怎么做的 (4)为什么初始化阶段才进行<code>data</code> 数据的合并？(这里指合并策略)</p>',31);p.render=function(s,t,p,o,c,u){return n(),a("div",null,[e])};export default p;export{t as __pageData};
